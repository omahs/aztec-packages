constant %N = 256;

namespace avmMini(%N);

//===== CONSTANT POLYNOMIALS ==================================================
pol constant clk(i) { i };
pol constant positive(i) { (i + 1) };
pol constant first = [1] + [0]*;

//===== TABLE SUBOP-TR ========================================================
// Enum over sub operations
// 0: LOAD
// 1: STORE
pol commit subop;

// Enum expressing intermediate register
// 0: Ia
// 1: Ib
// 2: Ic
pol commit inter_idx;

// We should range constrain it to 32 bits ultimately. For mini-AVM,
// we will assume that this column will be of the right type.
pol commit mem_idx;

// Track the last line of the execution trace. It does NOT correspond to the last row of the whole table
// of size N. As this depends on the supplied bytecode, this polynomial cannot be constant.
pol commit last;

// Relations on type constraints
subop * (1 - subop) = 0;
inter_idx * (1 - inter_idx) * (2 - inter_idx) = 0;


// ========= Table MEM-TR =================
pol commit m_clk;
pol commit m_addr;
pol commit m_val;
pol commit m_lastAccess; // Boolean (1 when this row is the last of a given address)
pol commit m_rw; // Enum: 0 (read), 1 (write)

// The table must be sorted by m_addr and then by m_clk.

// Type constraints
m_lastAccess * (1 - m_lastAccess) = 0;
m_rw * (1 - m_rw) = 0;

// m_lastAccess == 0 ==> m_addr' == m_addr
(1 - first) * (1 - m_lastAccess) * (m_addr' - m_addr) = 0;

// m_addr' == m_addr ==> m_lastAccess == 0
// This condition does not apply on the last row. 
// TODO: Uncomment when lookups are supported
// (1 - last) * m_lastAccess { (m_addr' - m_addr) } in positive; // Gated inclusion check. Is it supported?

// Alternatively to the above, on could require 
// that m_addr' - m_addr is 0 or 1 (needs to add placeholders m_addr values):
// (m_addr' - m_addr) * (m_addr' - m_addr) - (m_addr' - m_addr) = 0;
// if m_addr' - m_addr is 0 or 1, the following is equiv. to m_lastAccess
// (m_addr' - m_addr)

// m_lastAccess == 0 && m_rw' == 0 ==> m_val == m_val'
// This condition does not apply on the last row.
// Note: in barretenberg, a shifted polynomial will be 0 on the last row (shift is not cyclic)
// Note2: in barretenberg, if a poynomial is shifted, its non-shifted equivalent must be 0 on the first row

(1 - first) * (1 - last) * (1 - m_lastAccess) * (1 - m_rw') * (m_val' - m_val) = 0;
